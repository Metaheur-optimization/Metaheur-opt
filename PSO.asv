%% PSO first modified by KB 26 Dec 2020
function [AllBestFitnesses,AllBestSolution]=PSO(Out)
%% Setting and definition of variables
% rng('default')
rng(2)

AllBestFitnesses=zeros(Out.NRun,Out.MaxIter);
AllBestFitnesses=zeros(Out.NRun,Out.MaxIter);
Npopulation=Out.Npopulation; % Flock (population) size
NDecisionVariable=Out.NDecisionVariable; % Problem dimension (number of decision variables)
LowerBound=Out.LowerBound;
UpperBound=Out.UpperBound;
InterWeight=Out.InterWeight;% Inertia Weight
DampRatio=Out.DampRatio;% Inertia Weight Damping Ratio
c1=Out.c1; % Personahl Learning Coefficient
c2=Out.c2;% Global Learning Coefficient

Velocity=zeros(Npopulation,NDecisionVariable);
Best.Position=zeros(Npopulation,NDecisionVariable);
Best.Fitness=zeros(Npopulation,1);
GlobalBest.Position=zeros(1,NDecisionVariable);
GlobalBest.Fitness=zeros(1);

% Velocity Limits
LowerBound=LowerBound.';
UpperBound=UpperBound.';
VelMax=0.1*(UpperBound-LowerBound);
VelMin=-VelMax;

%% Main loop of indepdendent runs
for iRun=1:Out.NRun
    %% Initialisation
    Position=init(Out); % Initialization of solutions
    Fitness=EngineeringFunctions(Position,Out); % Fitness evaluation
    Best.Position=Position;
    Best.Fitness=Fitness;
    
    [GlobalBest.Fitness, LocationMin]=min(Best.Fitness);
    GlobalBest.Position(:)=Best.Position(LocationMin(1),:);
    
    %% PSO Main Loop
    Bestfit=zeros(Out.MaxIter,1);
    for it=1:Out.MaxIter
        
        for i=1:Npopulation
            
            % Update Velocity
            Velocity(i,:)= InterWeight*Velocity(i,:)+...
                c1*rand*(Best.Position(i,:)-Position(i,:))+...
                c2*rand*(GlobalBest.Position(1,:)-Position(i,:));
            
            % Apply Velocity Limits
            Velocity(i,:) = max(Velocity(i,:),VelMin(1,:));
            Velocity(i,:) = min(Velocity(i,:),VelMax(1,:));
            
            % Update Position
            Position(i,:) = Position(i,:)+ Velocity(i,:);
            
            % Velocity Mirror Effect
            IsOutside=(Position(i,:)<LowerBound(1,:) | Position(i,:)>UpperBound(1,:));
            Velocity(i,IsOutside)=-Velocity(i,IsOutside);
            
            % Apply Position Limits
            Position(i,:) = max(Position(i,:),LowerBound(1,:));
            Position(i,:) = min(Position(i,:),UpperBound(1,:));
        end
        
        Fitness=EngineeringFunctions(Position,Out); % Fitness evaluation
        
        % Evaluation
        for i=1:Npopulation
            % Update Personal Best
            if Fitness(i)<Best.Fitness(i)
                Best.Position(i,:)=Position(i,:);
                Best.Fitness(i)=Fitness(i);
                
                % Update Global Best
                if Best.Fitness(i)<GlobalBest.Fitness
                    GlobalBest.Position(:)=Best.Position(i,:);
                    GlobalBest.Fitness=Best.Fitness(i);
                end
            end
        end
        
        Bestfit(it)=GlobalBest.Fitness;
        InterWeight=InterWeight*DampRatio;
        %         disp(['Iteration ' num2str(it) ' Best Fitness = ' num2str(Bestfit(it))]);
        
    end
    
    %% Saving results of the solution
    AllBestSolution=GlobalBest.Position;
    AllBestFitnesses(iRun,:)=Bestfit;
end